# 并发问题

## 线程驱动 v.s. 事件驱动

线程驱动：编程简单直接，不需要处理异步和回调。例：Tomcat，Apache web server，每个请求由一个线程处理。

事件驱动：通常使用单线程事件循环或少量线程处理事件队列（event queue），减少了创建线程的开销，也减少了竞态问题，适合高并发。例：Nginx。

## 多进程并发 v.s. 多线程并发

### 多进程模型

子进程可以并行运行在多个处理器上，也可以被同一个处理器通过上下文切换进行 CPU 分时共享。创建进程和上下文切换的开销较大，但经过优化也可以支持高效处理  I/O 密集型任务（PostgreSQL）。

在涉及共享资源时，可能会有竞态问题。

### 多线程模型

通过 clone 系统调用创建线程。线程与进程的区别在于同一个进程内的线程**共享**着进程分配的资源，线程不被分配资源，只是操作系统调度执行任务的抽象的最小单元。

因为所有线程共享同一个进程的内存空间，所以**更容易**出现竞态问题。

### 实例

- Apache web server 是采用多进程与多线程混用的模型，在每个用户请求接入的时候都会通过 fork 系统调用创建一个子进程，如此同时支持多个用户，然后每个进程会派生线程，每个线程处理一条连接。
- PostgreSQL 使用多进程架构，每个连接一个进程

## 解决竞态问题的常见方法

### 共享内存

- 互斥锁：种类繁多且复杂，包括自旋锁、悲观锁和乐观锁
- 原子操作：线程安全而且性能很高，因为它是从 CPU 硬件层面做的更新，使用 CAS (compare-and-swap) 指令来更新原子变量。
- STM：相对于硬件/数据库层面的并发控制机制，software transactional memory 是指在软件层面实现关系型数据库中的事务。一个事物必须满足 ACID 性质。

### 消息通信

使用信号量，消息传递而不是共享内存。相比锁模型更安全高效。包括 CSP 模型和适用于分布式场景的 Actor 模型。
