# 如何实现一个哈希表？

### 理想的哈希函数

哈希函数将不同的键映射到不同的索引。

理想情况下，对一组键做哈希，得出来的哈希值都是不同的。这种情况下的时间复杂度是 O(1)。但这是不可能的，除非我们事先就知道所有的键。当我们谈论如何实现一个哈希算法，其实就是在谈论如何解决冲突（collision）的问题。

### 工程解法一

开放寻址法（open addressing scheme）是最简单粗暴的解法，就是如果计算出来的索引的位置被占用了，那就往后找，直到有空位置为止。

如果装载率（load factor）比较低，开放寻址的性能是比较好的。但当装载率超过 70% 的时候，性能就会急剧下降，当装载率达到 100%，整个哈希表就完全失效，时间复杂度为 O(n)，跟列表遍历没有区别了。

对于开放寻址法，常见的解决冲突问题的方式有 4 种。

在生成一个映射时，或进行查询时，如果遇到了碰撞的索引，需要向后依次找到空的索引槽，这个过程叫做线性探测（linear probing）。线性探测的时候，如果到了末尾，还可能回到开头，直到找完一个周期为止。

不过线性探测可以优化，因为开放寻址法会导致一个现象，就是经常键会堆在一起（clustering）。所以相对于挨个寻找，还有隔 3 个找（Plus 3 rehash），直到找到空白的区域；还有按平方间隔找（Quadratic probing），如果没有成功找到空的区域，就会平方下次搜寻的间隔数。

第 4 种方式是 double hashing，对于碰撞的键，再对哈希值做一遍哈希，会得到一个新的索引位置。

### 工程解法二

第二个介绍最常用的拉链法（chaining），也就闭合寻址法（closed addressing scheme），这种办法是在每一个索引的位置做一个链表（或者叫「桶」）。可以看作是一个二维链表。它同样也是在装载率越高的时候性能越差。一般来说，当装载量达到一定量之后，哈希表就会扩容（增加桶的数量）。