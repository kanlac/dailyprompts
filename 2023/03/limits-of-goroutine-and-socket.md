# Goroutine、文件描述符和套接字的上限

### goroutine 的上限
没有严格限制，上限取决于机器性能，一般为千万级。但是，在实际的生产环境中，应该根据实际需求和系统资源来决定要启动多少 goroutine，以避免过度使用系统资源和导致系统崩溃。

### 文件描述符开启数量的上限
在Go语言中，如果你想要限制启动goroutine的数量，有几种常见的方法：

一、**使用信号量（Semaphore）**：这是一种常见的限制并发数的技术。在Go语言中，你可以使用带缓冲的channel作为信号量。

例如，假设你只希望有10个并发的goroutine在运行。你可以创建一个带10个缓冲的channel。每次你启动一个goroutine，你就向这个channel发送一个值（入队）。如果channel已满，这个操作会阻塞，直到有其他goroutine完成并从channel中读取一个值（出队）。

```go
sem := make(chan struct{}, 10)

for i := 0; i < numJobs; i++ {
    sem <- struct{}{} // 入队操作，如果channel已满，此操作会阻塞

    go func(i int) {
        defer func() { <-sem }() // 出队操作，在goroutine结束时执行

        // do the job
    }(i)
}

```

二、**使用第三方库**：有许多第三方库提供了更高级的功能，如工作池（worker pool）。这些库通常提供了易于使用的API，并可以处理错误和其他边缘情况。例如，“ants”就是一个非常流行的Go语言并发库，它提供了一个高效的goroutine池。

以上就是限制goroutine数量的一些常见方法，不过最重要的是，你应该根据你的具体需求和环境来选择最合适的策略。

### 文件描述符和用户进程数量的默认限制

Linux系统的默认`ulimit`值可能会因不同的发行版和配置而变化。然而，常见的默认值有以下两种：

1. 文件描述符（file descriptors）的默认限制通常设置为1024。你可以通过运行`ulimit -n`来查看当前shell的文件描述符的软限制。
2. 用户进程数量（user processes）的默认限制通常设置为多达几千个，取决于系统的内存大小。你可以通过运行`ulimit -u`来查看当前shell的用户进程的软限制。

请注意，这些只是常见的默认值，实际值可能会有所不同。此外，超级用户（root）或系统管理员可以更改这些默认值，以适应特定的系统需求或性能目标。

如果你想要查看系统的所有`ulimit`值，你可以简单地运行`ulimit -a`。这将显示当前shell的所有资源限制。

### 单个 socket 或文件可以进行的并发操作数量上限

~~在 linux 中，每个 socket 或文件都有一个关联的数据结构（缓存）。每个缓存可以支持的最大并发操作数量，在不同的系统和网络协议栈中有所不同，一般在几百到数千个之间。~~

在Linux中，每个打开的文件或套接字都有一个与之关联的文件描述符，并且内核确实维护了一些数据结构来管理这些文件描述符及其相关的资源。但是，这些数据结构不应被理解为缓存，它们更像是用来维护和追踪打开的文件和套接字状态的元数据。

至于每个文件或套接字可以支持的“最大并发操作数量”，这个概念可能需要进一步的解释。在大多数情况下，你可以在一个文件或套接字上进行多个并发读或写操作，但这并不意味着这些操作都会同时进行。相反，操作系统通常会对这些操作进行排队，并按照一定的顺序进行处理。

因此，一个文件或套接字可以“支持”的并发操作数量实际上取决于操作系统如何处理并发I/O请求，以及它如何排队和调度这些请求。这个数量并不固定，而是由操作系统的I/O子系统、硬件资源、文件系统和网络协议栈等多个因素共同决定的。

`panic: too many concurrent operations on a single file or socket (max 1048575)`

根据以上实际报错内容得知，Go 的并发操作上限为百万级别。

这个限制在Go的netpoller实现中，该实现是Go的异步I/O机制的一部分。具体来说，如果你试图在单个文件或socket上同时执行超过1048575个操作，你会遇到你所提到的那个错误。

这个限制源于Go使用32位整数来追踪每个文件或socket上的并发操作。其中的一些位被用于其他目的，剩下的位用于追踪并发操作。在这种设置下，最大的并发操作数是1048575。

但是，需要注意的是，在实际应用中，大多数情况下不太可能达到这个限制，因为在单个文件或socket上同时执行这么多操作通常是不理想的。这种情况下，一个更好的解决方案可能是使用更多的文件或sockets，或者使用一种更有效的并发控制策略。