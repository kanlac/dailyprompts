# panic, recover and defer

### 问题
一、一个 goroutine 发生 panic 后，会影响其他 goroutine 执行吗？

二、以下程序执行结果？
```go
func main() {
  fmt.Print("1 ")
  defer recover()
  fmt.Print("2 ")
  var a []int
  _ = a[0]
  fmt.Print("3 ")
}
```

三、重复 panic
```go
func main() {
    defer func() { fmt.Println(recover()) }()
    defer func() { fmt.Println(recover()) }()
    defer panic(1)
    panic(2)
}
```
以上程序打印：
- A: 2 `<nil>`
- B: 1 `<nil>`
- C: 2 1
- D: 1 2
- E: 直接 panic

四、计算函数的运行时间
```go
func main() {
	startedAt := time.Now()
	defer fmt.Println(time.Since(startedAt))

	time.Sleep(time.Second)
}
```

五、defer 套娃
```go
func main() {
	defer fmt.Println("recover: ", recover())
	panic(1)
}
```

```go
func main() {
	defer func() {
		fmt.Println("recover: ", recover())
	}()
	panic(1)
}
```

```go
func main() {
	defer func() {
		func() { fmt.Println("recover: ", recover()) }()
	}()
	panic(1)
}
```

六、defer 的实现原理？


### 回答
一、会。当一个 goroutine 发生 panic，它会向它的父级 goroutine 抛出 panic，直到某个父级 goroutine 捕获（recover）。如果都没有 recover，则整个程序终止执行

二、`1, 2, panic`

三、B，因为 defer panic 会覆盖 panic

四、`125ns`，几乎为 0s。因为调用 defer 关键字会立刻拷贝函数中引用的外部参数，所以以 `time.Since(startedAt)` 的结果不是在 main 函数退出之前计算的，而是在 defer 关键字调用时计算的（[ref](https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/)）

五、
1. `<nil>`, `panic: 1`，捕获不到 panic，因为 defer 函数的参数会做预处理，即刻进行值拷贝
2. `recover: 1`
3. `<nil>`, `panic: 1`，捕获不到 panic

六、
Generated By ChatGPT(GPT4):

`defer` 是 Go 语言中的一个关键字，它允许我们在函数返回之前执行一些操作，例如关闭文件、解锁资源、回收内存等。`defer` 的实现原理依赖于 Go 语言的运行时系统（runtime system）和数据结构。

Go 语言的运行时系统在函数调用栈上维护了一个称为 "deferred function stack" 的数据结构。当遇到 `defer` 关键字时，Go 语言会将相关的函数和参数信息压入这个栈中。当函数准备返回时，运行时系统会按照 LIFO（后进先出，Last In First Out）的顺序从栈中取出所有的延迟函数并执行它们。

以下是 Go 语言中 `defer` 的实现原理的详细步骤：

1. 当遇到 `defer` 语句时，编译器会生成一个包含有关延迟函数的信息（如函数指针、参数值等）的结构体。
2. 这个结构体会被压入当前 goroutine 的 "deferred function stack"。
3. 在函数返回之前，运行时系统会从 "deferred function stack" 弹出所有的延迟函数。
4. 弹出的延迟函数会按照 LIFO 顺序执行，即最后压入栈的函数会最先被执行。

需要注意的是，`defer` 语句的执行是有一定的性能开销的。因为运行时系统需要维护 "deferred function stack" 和在函数返回时执行延迟函数。但是，这种开销通常可以被接受，因为它带来了代码的可读性和可维护性的提升。当然，在关注性能的场景下，可以考虑手动管理资源回收，以避免使用 `defer` 带来的额外开销。