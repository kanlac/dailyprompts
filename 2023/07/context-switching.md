# 上下文切换

# Q
- 何时发生上下文切换？
- 为什么要减少上下文切换？如何减少？
- 使用什么工具可以查看量化指标？

# A

一句话概述：CPU 进行任何切换的时候，会发生上下文切换；上下文切换使得多个线程可以共享一个 CPU。

一个 CPU 在同一时刻只能处理一个任务，在一些情况下，当前任务未处理完，就需要切换到其他任务，这个过程就叫做上下文切换（context switching）。就像你正看着书，你妈叫你过去干活，为了记住看到了哪里，你放了一个书签，以便接下来从原来的地方继续。对于操作系统来说，放书签的操作等同于将进程的状态和相关信息存储到一个 PCB（进程控制块）中，未来重新执行的时候，再把这些信息放回寄存器中。

具体来说，上下文存储在 PCB（进程控制块）中。操作系统中，每个进程都是用一个 PCB 来表示的。当 CPU 在接收到一个系统调用的时候，会将用户态的进程的状态存储到一个 PCB 中，然后加载内核态进程的上下文。

### 何时发生

操作系统在任务（进程或线程）之间切换时，会发生上下文切换。这种切换通常由操作系统的调度程序管理。具体有以下几种情况：

1. 任务结束：当一个任务执行完毕，或者被明确地结束（如被其他任务杀死），系统需要进行上下文切换，把CPU的控制权交给其他任务
2. 阻塞：当一个任务等待某些资源（例如，等待I/O操作完成或等待锁）而被阻塞时，操作系统会进行上下文切换，将CPU控制权转交给另一个就绪的任务
3. 中断处理：当CPU接收到一个中断请求（例如，硬件中断或软件中断）时，操作系统可能会暂停当前任务的执行，保存其上下文，然后转去处理中断。处理完中断后，操作系统会恢复被中断任务的上下文，让它继续执行。这个过程也涉及上下文切换
    
    当一个用户程序调用系统调用时，会触发一个软件中断/异常（software interrupt/exception, SWI），代码的执行会从用户程序切换到操作系统的中断向量表（Interrupt Vector Table, IVT）中预定义的位置，切换到内核模式执行指令。
    
4. 抢占式调度：在抢占式多任务处理中，如果一个任务的执行时间超过了预定的**时间片**，操作系统会强制进行上下文切换，让其他任务有机会运行
5. 优先级调度： 在优先级调度中，高优先级的任务可以抢占低优先级任务的CPU时间。当一个高优先级的任务就绪时，系统可能需要发生上下文切换，让它替代当前正在运行的低优先级任务

### 要减少上下文切换

频繁的上下文切换会影响性能。许多的性能优化设计都是为了减少上下文切换的次数。

Go 调度器使用和 CPU 数量相等的线程数，以减少线程频繁的上下文切换带来的内存开销；同时，在每个线程上执行额外开销更低的 goroutine。

每一次线程切换上下文的耗时约为 1us，而每一次 goroutine 切换上下文的耗时约为 0.2us，减少了 80% 的额外开销。

### 频繁读取文件对系统性能有什么影响？

如果一个程序频繁地进行文件读取或其他需要系统调用的操作，那么会经常发生从用户态到内核态的上下文切换。这样的频繁上下文切换会带来以下几个问题：

1. **开销**：每次上下文切换都需要保存当前执行上下文（例如寄存器状态）并恢复另一个上下文。这是有开销的，并且在频繁切换时会消耗大量的CPU时间。
2. **缓存失效**：CPU有缓存（例如L1、L2、L3缓存）来加速数据和指令的访问。上下文切换可能导致缓存的内容失效，进而增加从主内存中获取数据的延迟。
3. **调度延迟**：上下文切换可能导致线程或进程调度延迟，从而影响程序的响应时间。

为了降低这些开销，系统和应用程序设计者会采用多种策略：

1. **批处理**：尽量减少系统调用的次数，例如，通过一次读取更多的数据，而不是频繁地读取小块数据。
2. **异步I/O**：使用异步I/O可以允许应用程序在等待数据时继续执行其他任务，而不需要进行上下文切换。
3. **内存映射文件**：通过`mmap`之类的调用将文件内容映射到进程的地址空间，这样，文件的读取和写入就可以通过内存操作来完成，而不需要额外的`read`或`write`系统调用。
4. **使用专门的I/O线程**：某些应用可能会创建专门的线程来处理所有的I/O操作，这样，CPU密集型的任务和I/O操作可以在不同的线程中并行执行，降低了上下文切换的开销。

但是，尽管这些策略可以帮助减少上下文切换的开销，它们并不能完全消除。因此，设计高性能的系统和应用程序需要仔细地考虑上下文切换和其他与系统调用相关的开销。

### 如何查看相关指标

`pidstat -w 1`，查看 `cswch/s` 列。
