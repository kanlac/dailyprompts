# GMP 模型

### Q
- 介绍 GMP 模型
- 为什么需要 P？

### A
Go 中为解决内核线程和用户线程之间多对多的映射关系而使用的一种模型。GMP 指的是运行时调度器的数据结构。

为什么要用多对多的关系呢？因为这样既可以利用多线程的硬件优势，又可以省去两个空间频繁上下文切换的成本。

- M for machine threads，操作系统线程（可进入内核空间），worker threads：实际执行 G 的实体。它先获取 P，从 P 的队列中取到 G 执行。队列为空时，它会从全局队列或其它 P 的本地队列中拿一批 G，放到 P 的队列。
调度器最多可以创建 10000 个线程（M），但其中大部分线程不会执行用户态代码，最多只会有 GOMAXPROCS 个活跃线程。默认情况下，运行时会将 GOMAXPROCS 设置为机器的 CPU 核数，这样就默认不会触发操作系统的线程调度和上下文切换，所有调度都发生在用户态，由 Go 调度器触发，能够减少很多额外开销。
- P 逻辑处理器：Go 1.1 中才引进的一个概念，它是调度器中的概念，它包含执行 Go 代码所需要的资源（such as a scheduler, or a memory allocator state），即上下文。可以将 P 看作一个局部的调度器，如果 M 想要运行 G，必须先获取 P。每个 P 都有一个 G 的本地队列。调度器在启动时会创建 GOMAXPROCS 个数量的 P。P 是实现 M：N 调度的关键。

为什么需要 P？（[来源](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.c3s328639mw9)）：

- 全局队列有一个互斥锁，该互斥锁保护所有与 goroutine 相关的操作（创建、完成、重新调度等），且各个 M 需要频繁交接可运行的 G，从而导致锁竞争严重。引入 P 后，每个 P 有本地队列，新建 G 时，优先加入本地队列。如果本地队列满了，则把队列中一半的 G 移动到全局队列，可以大大缓解锁竞争问题
- 每个 M 中都有与之相关联的内存缓存，而在这些缓存中，实际需要执行的 Go 代码的占比可能很低（最低 1/100）。引入 P 后，这些缓存都可以与 P 相绑定，而不是与 M 绑定，大大减少资源消耗